# 设计模式 - web协绘坊

本文档详细介绍 web协绘坊项目中使用的设计模式，包括模式的选择理由、实现细节和实际应用场景。

## 目录

- [设计模式概览](#设计模式概览)
- [策略模式 - 工具切换系统](#策略模式---工具切换系统)
- [命令模式 - 撤销/重做系统](#命令模式---撤销重做系统)
- [发布-订阅模式 - 事件系统](#发布-订阅模式---事件系统)
- [工厂模式 - 图形创建](#工厂模式---图形创建)
- [单例模式 - 错误处理器](#单例模式---错误处理器)
- [模板方法模式 - 图形基类](#模板方法模式---图形基类)
- [设计模式总结](#设计模式总结)

---

## 设计模式概览

本项目使用了多种经典设计模式，以实现代码的高内聚、低耦合：

| 设计模式 | 应用场景 | 解决的问题 | 文件位置 |
|---------|---------|-----------|---------|
| **策略模式** | 工具切换系统 | 避免大量 if-else，支持工具扩展 | `core/ToolManager.ts` |
| **命令模式** | 撤销/重做系统 | 将操作封装为对象，支持操作历史 | `core/CommandManager.ts` |
| **发布-订阅** | 事件系统 | 解耦模块之间的依赖关系 | `core/EventEmitter.ts` |
| **工厂模式** | 图形创建 | 根据类型动态创建图形实例 | `shapes/index.ts` |
| **单例模式** | 错误处理器 | 全局唯一的错误处理实例 | `core/ErrorHandler.ts` |
| **模板方法** | 图形基类 | 定义算法骨架，子类实现细节 | `shapes/Shape.ts` |

---

## 策略模式 - 工具切换系统

### 为什么使用策略模式？

在图形编辑器中，用户可以切换不同的绘图工具（选择、矩形、圆形、钢笔、画笔）。如果使用 if-else 判断当前工具类型，会导致：

❌ **问题**：
```typescript
// 不好的做法：使用 if-else
handlePointerDown(event: PointerEvent) {
  if (this.currentTool === 'select') {
    // 选择工具的处理逻辑（50行代码）
  } else if (this.currentTool === 'rect') {
    // 矩形工具的处理逻辑（50行代码）
  } else if (this.currentTool === 'circle') {
    // 圆形工具的处理逻辑（50行代码）
  }
  // ... 更多工具
}
```

**缺点**：
1. 代码冗长，难以维护
2. 违反开闭原则（新增工具需要修改现有代码）
3. 职责不清晰，所有逻辑混在一起

✅ **策略模式解决方案**：

### 实现

#### 1. 定义工具接口（抽象策略）

```typescript
// tools/Tool.ts
export abstract class Tool {
  protected editor: Editor;

  constructor(editor: Editor) {
    this.editor = editor;
  }

  // 定义工具的标准行为
  abstract onPointerDown(event: PointerEvent): void;
  abstract onPointerMove(event: PointerEvent): void;
  abstract onPointerUp(event: PointerEvent): void;
  abstract onKeyDown(event: KeyboardEvent): void;

  // 生命周期方法
  activate(): void {
    console.log(`${this.constructor.name} activated`);
  }

  deactivate(): void {
    console.log(`${this.constructor.name} deactivated`);
  }
}
```

#### 2. 实现具体策略（具体工具）

```typescript
// tools/RectTool.ts - 矩形工具
export class RectTool extends Tool {
  private startPoint: Vector | null = null;
  private currentRect: Rect | null = null;

  onPointerDown(event: PointerEvent): void {
    this.startPoint = this.editor.screenToWorld(
      new Vector(event.clientX, event.clientY)
    );

    this.currentRect = new Rect({
      x: this.startPoint.x,
      y: this.startPoint.y,
      width: 0,
      height: 0,
      fill: '#3498db',
      stroke: '#2980b9'
    });
  }

  onPointerMove(event: PointerEvent): void {
    if (!this.startPoint || !this.currentRect) return;

    const currentPoint = this.editor.screenToWorld(
      new Vector(event.clientX, event.clientY)
    );

    // 约束正方形（按住 Shift）
    let width = currentPoint.x - this.startPoint.x;
    let height = currentPoint.y - this.startPoint.y;

    if (event.shiftKey) {
      const size = Math.max(Math.abs(width), Math.abs(height));
      width = width >= 0 ? size : -size;
      height = height >= 0 ? size : -size;
    }

    this.currentRect.width = width;
    this.currentRect.height = height;
    this.editor.requestRender();
  }

  onPointerUp(): void {
    if (this.currentRect && this.currentRect.width !== 0 && this.currentRect.height !== 0) {
      const command = new AddShapeCommand(this.editor.scene, this.currentRect);
      this.editor.executeCommand(command);
    }

    this.startPoint = null;
    this.currentRect = null;
  }

  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.startPoint = null;
      this.currentRect = null;
      this.editor.requestRender();
    }
  }
}
```

```typescript
// tools/SelectTool.ts - 选择工具
export class SelectTool extends Tool {
  private isDragging = false;
  private dragStartPoint: Vector | null = null;

  onPointerDown(event: PointerEvent): void {
    const worldPoint = this.editor.screenToWorld(
      new Vector(event.clientX, event.clientY)
    );

    // 点击测试
    const clickedShape = this.editor.scene.getShapeAtPoint(worldPoint);

    if (clickedShape) {
      // 多选逻辑（按住 Ctrl/Cmd）
      if (event.ctrlKey || event.metaKey) {
        this.editor.selection.toggle(clickedShape);
      } else {
        this.editor.selection.set([clickedShape]);
      }
      this.isDragging = true;
      this.dragStartPoint = worldPoint;
    } else {
      // 框选开始
      this.editor.selection.clear();
      this.startMarqueeSelection(worldPoint);
    }
  }

  onPointerMove(event: PointerEvent): void {
    if (!this.isDragging || !this.dragStartPoint) return;

    const currentPoint = this.editor.screenToWorld(
      new Vector(event.clientX, event.clientY)
    );

    const delta = currentPoint.subtract(this.dragStartPoint);

    // 拖拽选中的图形
    this.editor.selection.selectedShapes.forEach(shape => {
      shape.x += delta.x;
      shape.y += delta.y;
    });

    this.dragStartPoint = currentPoint;
    this.editor.requestRender();
  }

  onPointerUp(): void {
    if (this.isDragging) {
      // 创建变换命令（支持撤销）
      const command = new TransformCommand(/* ... */);
      this.editor.executeCommand(command);
    }

    this.isDragging = false;
    this.dragStartPoint = null;
  }

  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Delete' || event.key === 'Backspace') {
      this.editor.deleteSelected();
    }
  }
}
```

#### 3. 策略管理器（Context）

```typescript
// core/ToolManager.ts
export class ToolManager {
  private tools = new Map<ToolType, Tool>();
  private currentTool: Tool | null = null;

  constructor(private editor: Editor) {
    // 注册所有工具
    this.registerTool('select', new SelectTool(editor));
    this.registerTool('rect', new RectTool(editor));
    this.registerTool('circle', new CircleTool(editor));
    this.registerTool('pen', new PenTool(editor));
    this.registerTool('brush', new BrushTool(editor));
  }

  // 注册工具
  registerTool(type: ToolType, tool: Tool): void {
    this.tools.set(type, tool);
  }

  // 切换工具
  setTool(type: ToolType): void {
    // 停用当前工具
    if (this.currentTool) {
      this.currentTool.deactivate();
    }

    // 激活新工具
    this.currentTool = this.tools.get(type) || null;
    if (this.currentTool) {
      this.currentTool.activate();
    }
  }

  // 委托事件给当前工具
  handlePointerDown(event: PointerEvent): void {
    this.currentTool?.onPointerDown(event);
  }

  handlePointerMove(event: PointerEvent): void {
    this.currentTool?.onPointerMove(event);
  }

  handlePointerUp(event: PointerEvent): void {
    this.currentTool?.onPointerUp(event);
  }

  handleKeyDown(event: KeyboardEvent): void {
    this.currentTool?.onKeyDown(event);
  }
}
```

### 优点

1. ✅ **开闭原则**：新增工具只需创建新的 Tool 子类，无需修改现有代码
2. ✅ **单一职责**：每个工具类只负责一种工具的逻辑
3. ✅ **代码清晰**：工具逻辑分离，易于理解和维护
4. ✅ **易于测试**：可以单独测试每个工具

### 实际应用

```typescript
// 在 Vue 组件中使用
const handleToolChange = (toolType: ToolType) => {
  editor.value?.setTool(toolType);
};

// 用户点击工具栏按钮
<button @click="handleToolChange('rect')">矩形</button>
<button @click="handleToolChange('circle')">圆形</button>
```

---

## 命令模式 - 撤销/重做系统

### 为什么使用命令模式？

在图形编辑器中，用户需要撤销（Ctrl+Z）和重做（Ctrl+Y）操作。命令模式将操作封装为对象，便于实现：
- 操作历史记录
- 撤销/重做功能
- 操作序列化（用于协同编辑）

### 实现

#### 1. 定义命令接口

```typescript
// commands/Command.ts
export interface Command {
  // 执行命令
  execute(): void;

  // 撤销命令
  undo(): void;

  // 序列化为 JSON（用于协同编辑）
  toJSON(): any;
}
```

#### 2. 实现具体命令

```typescript
// commands/AddShapeCommand.ts - 添加图形命令
export class AddShapeCommand implements Command {
  constructor(
    private scene: Scene,
    private shape: Shape
  ) {}

  execute(): void {
    this.scene.add(this.shape);
  }

  undo(): void {
    this.scene.remove(this.shape);
  }

  toJSON(): any {
    return {
      type: 'add-shape',
      shape: this.shape.toJSON()
    };
  }
}
```

```typescript
// commands/DeleteShapeCommand.ts - 删除图形命令
export class DeleteShapeCommand implements Command {
  constructor(
    private scene: Scene,
    private shapes: Shape[]
  ) {}

  execute(): void {
    this.shapes.forEach(shape => {
      this.scene.remove(shape);
    });
  }

  undo(): void {
    this.shapes.forEach(shape => {
      this.scene.add(shape);
    });
  }

  toJSON(): any {
    return {
      type: 'delete-shape',
      shapeIds: this.shapes.map(s => s.id)
    };
  }
}
```

```typescript
// commands/TransformCommand.ts - 变换命令
export class TransformCommand implements Command {
  constructor(
    private shape: Shape,
    private oldTransform: { x: number; y: number; width: number; height: number },
    private newTransform: { x: number; y: number; width: number; height: number }
  ) {}

  execute(): void {
    Object.assign(this.shape, this.newTransform);
  }

  undo(): void {
    Object.assign(this.shape, this.oldTransform);
  }

  toJSON(): any {
    return {
      type: 'transform-shape',
      shapeId: this.shape.id,
      oldTransform: this.oldTransform,
      newTransform: this.newTransform
    };
  }
}
```

```typescript
// commands/UpdateStyleCommand.ts - 更新样式命令
export class UpdateStyleCommand implements Command {
  constructor(
    private shapes: Shape[],
    private oldStyles: Map<string, Partial<ShapeStyle>>,
    private newStyle: Partial<ShapeStyle>
  ) {}

  execute(): void {
    this.shapes.forEach(shape => {
      Object.assign(shape, this.newStyle);
    });
  }

  undo(): void {
    this.shapes.forEach(shape => {
      const oldStyle = this.oldStyles.get(shape.id);
      if (oldStyle) {
        Object.assign(shape, oldStyle);
      }
    });
  }

  toJSON(): any {
    return {
      type: 'update-style',
      shapeIds: this.shapes.map(s => s.id),
      style: this.newStyle
    };
  }
}
```

#### 3. 命令管理器（Invoker）

```typescript
// core/CommandManager.ts
export class CommandManager extends EventEmitter {
  private undoStack: Command[] = [];  // 撤销栈
  private redoStack: Command[] = [];  // 重做栈
  private maxHistorySize = 100;       // 最大历史记录数

  // 执行命令
  execute(command: Command): void {
    // 1. 执行命令
    command.execute();

    // 2. 添加到撤销栈
    this.undoStack.push(command);

    // 3. 清空重做栈（执行新命令后，原来的"未来"就失效了）
    this.redoStack = [];

    // 4. 限制历史大小
    if (this.undoStack.length > this.maxHistorySize) {
      this.undoStack.shift();  // 移除最旧的命令
    }

    // 5. 触发事件
    this.emit('historyChanged');
  }

  // 撤销
  undo(): boolean {
    const command = this.undoStack.pop();
    if (command) {
      command.undo();
      this.redoStack.push(command);
      this.emit('historyChanged');
      return true;
    }
    return false;
  }

  // 重做
  redo(): boolean {
    const command = this.redoStack.pop();
    if (command) {
      command.execute();
      this.undoStack.push(command);
      this.emit('historyChanged');
      return true;
    }
    return false;
  }

  // 检查是否可以撤销
  canUndo(): boolean {
    return this.undoStack.length > 0;
  }

  // 检查是否可以重做
  canRedo(): boolean {
    return this.redoStack.length > 0;
  }

  // 清空历史
  clear(): void {
    this.undoStack = [];
    this.redoStack = [];
    this.emit('historyChanged');
  }

  // 获取历史记录
  getHistory(): { undo: Command[]; redo: Command[] } {
    return {
      undo: [...this.undoStack],
      redo: [...this.redoStack]
    };
  }
}
```

### 优点

1. ✅ **解耦**：请求者（UI）与执行者（业务逻辑）解耦
2. ✅ **可扩展**：新增操作只需创建新的 Command 类
3. ✅ **支持撤销/重做**：命令对象保存了执行和撤销的逻辑
4. ✅ **支持宏命令**：可以组合多个命令为一个复合命令
5. ✅ **可序列化**：命令可以序列化为 JSON，用于协同编辑

### 实际应用

```typescript
// Editor.ts - 使用命令管理器
export class Editor {
  private commandManager = new CommandManager();

  // 添加图形
  addShape(shape: Shape): void {
    const command = new AddShapeCommand(this.scene, shape);
    this.commandManager.execute(command);
  }

  // 删除选中的图形
  deleteSelected(): void {
    const shapes = this.selection.selectedShapes;
    if (shapes.length > 0) {
      const command = new DeleteShapeCommand(this.scene, shapes);
      this.commandManager.execute(command);
      this.selection.clear();
    }
  }

  // 更新样式
  updateStyle(style: Partial<ShapeStyle>): void {
    const shapes = this.selection.selectedShapes;
    const oldStyles = new Map();
    shapes.forEach(shape => {
      oldStyles.set(shape.id, { ...shape });
    });

    const command = new UpdateStyleCommand(shapes, oldStyles, style);
    this.commandManager.execute(command);
  }

  // 键盘快捷键
  handleKeyboard(event: KeyboardEvent): void {
    if (event.ctrlKey || event.metaKey) {
      if (event.key === 'z') {
        this.commandManager.undo();
        event.preventDefault();
      } else if (event.key === 'y') {
        this.commandManager.redo();
        event.preventDefault();
      }
    }
  }
}
```

---

## 发布-订阅模式 - 事件系统

### 为什么使用发布-订阅模式？

在图形编辑器中，不同模块需要对某些事件做出响应，例如：
- UI 组件需要响应选择变化，更新属性面板
- 协同服务需要响应命令执行，同步给其他用户
- 性能监控需要响应渲染事件，更新 FPS

如果直接调用，会导致模块之间强耦合。

### 实现

```typescript
// core/EventEmitter.ts
export class EventEmitter {
  private listeners = new Map<string, Set<Function>>();

  // 注册事件监听器
  on(event: string, callback: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);
  }

  // 注销事件监听器
  off(event: string, callback: Function): void {
    this.listeners.get(event)?.delete(callback);
  }

  // 触发事件
  emit(event: string, ...args: any[]): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(...args);
        } catch (error) {
          console.error(`Error in event listener for "${event}":`, error);
        }
      });
    }
  }

  // 一次性监听器
  once(event: string, callback: Function): void {
    const wrapper = (...args: any[]) => {
      callback(...args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }

  // 清除所有监听器
  clear(): void {
    this.listeners.clear();
  }

  // 清除特定事件的所有监听器
  clearEvent(event: string): void {
    this.listeners.delete(event);
  }
}
```

### 优点

1. ✅ **解耦**：发布者和订阅者互不依赖
2. ✅ **灵活**：可以动态添加/移除监听器
3. ✅ **一对多**：一个事件可以有多个监听器
4. ✅ **扩展性**：新增功能只需添加监听器，无需修改现有代码

### 实际应用

```typescript
// Editor.ts - 触发事件
export class Editor extends EventEmitter {
  addShape(shape: Shape): void {
    this.scene.add(shape);
    this.emit('shapeAdded', shape);  // 触发事件
  }

  setSelection(shapes: Shape[]): void {
    this.selection.set(shapes);
    this.emit('selectionChanged', shapes);  // 触发事件
  }

  executeCommand(command: Command): void {
    this.commandManager.execute(command);
    this.emit('commandExecuted', command);  // 触发事件
  }
}

// 在 Vue 组件中订阅事件
onMounted(() => {
  const editor = editorRef.value;

  // 监听选择变化，更新属性面板
  editor.on('selectionChanged', (shapes: Shape[]) => {
    selectedShapes.value = shapes;
  });

  // 监听图形添加，记录日志
  editor.on('shapeAdded', (shape: Shape) => {
    console.log('Shape added:', shape);
  });

  // 监听命令执行，同步到服务器
  editor.on('commandExecuted', (command: Command) => {
    if (ws.value && !isReceivingRemote) {
      ws.value.send(JSON.stringify({
        type: 'command',
        data: command.toJSON()
      }));
    }
  });
});

onUnmounted(() => {
  // 清理监听器，防止内存泄漏
  editor.clear();
});
```

---

## 工厂模式 - 图形创建

### 为什么使用工厂模式？

在反序列化图形数据时（例如从服务器获取、从本地存储加载），需要根据类型字符串创建对应的图形实例。

❌ **不使用工厂模式**：
```typescript
function createShape(data: any): Shape {
  if (data.type === 'Rect') {
    return new Rect(data);
  } else if (data.type === 'Circle') {
    return new Circle(data);
  } else if (data.type === 'Line') {
    return new Line(data);
  }
  // ... 每添加新图形都要修改这里
}
```

### 实现

```typescript
// shapes/index.ts
export function createShapeFromJSON(data: any): Shape | null {
  switch (data.type) {
    case 'Rect':
      return new Rect(data);
    case 'Circle':
      return new Circle(data);
    case 'Line':
      return new Line(data);
    default:
      console.warn(`Unknown shape type: ${data.type}`);
      return null;
  }
}

// 也可以使用映射表
const shapeConstructors = {
  'Rect': Rect,
  'Circle': Circle,
  'Line': Line
};

export function createShapeFromJSON2(data: any): Shape | null {
  const Constructor = shapeConstructors[data.type];
  if (Constructor) {
    return new Constructor(data);
  }
  console.warn(`Unknown shape type: ${data.type}`);
  return null;
}
```

### 实际应用

```typescript
// 从服务器加载房间数据
async function loadRoom(roomId: string) {
  const response = await fetch(`/api/rooms/${roomId}`);
  const roomData = await response.json();

  // 使用工厂函数创建图形实例
  roomData.shapes.forEach((shapeData: any) => {
    const shape = createShapeFromJSON(shapeData);
    if (shape) {
      editor.scene.add(shape);
    }
  });
}

// 处理 WebSocket 消息
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);

  if (message.type === 'command') {
    const { command } = message.data.operation;

    if (command.type === 'add-shape') {
      const shape = createShapeFromJSON(command.shape);
      if (shape) {
        editor.scene.add(shape);
        editor.requestRender();
      }
    }
  }
};
```

---

## 单例模式 - 错误处理器

### 为什么使用单例模式？

错误处理器需要全局唯一，所有模块应该使用同一个实例来记录和处理错误。

### 实现

```typescript
// core/ErrorHandler.ts
export class ErrorHandler {
  private static instance: ErrorHandler;
  private errors: Error[] = [];
  private maxErrors = 100;

  // 私有构造函数，防止外部直接创建实例
  private constructor() {}

  // 获取单例实例
  static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }

  // 处理错误
  handle(error: Error, context: string): void {
    console.error(`[${context}]`, error);

    this.errors.push(error);

    // 限制错误数量
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
  }

  // 处理渲染错误
  handleRenderError(error: Error): void {
    this.handle(error, 'Render');
  }

  // 处理命令错误
  handleCommandError(error: Error): void {
    this.handle(error, 'Command');
  }

  // 获取错误历史
  getErrors(): Error[] {
    return [...this.errors];
  }

  // 清空错误
  clearErrors(): void {
    this.errors = [];
  }
}
```

### 实际应用

```typescript
// Editor.ts
render(): void {
  try {
    // 渲染逻辑
    this.renderBackground();
    this.renderShapes();
    this.renderSelection();
  } catch (error) {
    ErrorHandler.getInstance().handleRenderError(error as Error);
  }
}

// CommandManager.ts
execute(command: Command): void {
  try {
    command.execute();
    this.undoStack.push(command);
    this.emit('historyChanged');
  } catch (error) {
    ErrorHandler.getInstance().handleCommandError(error as Error);
  }
}
```

---

## 模板方法模式 - 图形基类

### 为什么使用模板方法模式？

所有图形都有一些共同的行为（渲染、碰撞检测、序列化），但具体实现不同。模板方法模式定义算法骨架，子类实现具体步骤。

### 实现

```typescript
// shapes/Shape.ts - 图形基类
export abstract class Shape {
  public id: string;
  public x: number;
  public y: number;
  public fill: string | null;
  public stroke: string | null;
  public lineWidth: number;
  public opacity: number;

  constructor(options: ShapeOptions) {
    this.id = options.id || generateId();
    this.x = options.x || 0;
    this.y = options.y || 0;
    this.fill = options.fill || null;
    this.stroke = options.stroke || '#000000';
    this.lineWidth = options.lineWidth || 2;
    this.opacity = options.opacity || 1;
  }

  // 模板方法：定义渲染算法骨架
  render(ctx: CanvasRenderingContext2D): void {
    ctx.save();

    // 1. 应用通用样式
    this.applyStyle(ctx);

    // 2. 绘制图形（由子类实现）
    this.draw(ctx);

    // 3. 绘制边框
    if (this.stroke) {
      ctx.strokeStyle = this.stroke;
      ctx.lineWidth = this.lineWidth;
      ctx.stroke();
    }

    // 4. 填充
    if (this.fill) {
      ctx.fillStyle = this.fill;
      ctx.fill();
    }

    ctx.restore();
  }

  // 应用样式（通用方法）
  private applyStyle(ctx: CanvasRenderingContext2D): void {
    ctx.globalAlpha = this.opacity;
  }

  // 抽象方法：由子类实现具体绘制逻辑
  protected abstract draw(ctx: CanvasRenderingContext2D): void;

  // 抽象方法：碰撞检测
  abstract containsPoint(point: Vector): boolean;

  // 抽象方法：��取边界框
  abstract getBounds(): AABB;

  // 模板方法：序列化
  toJSON(): any {
    return {
      id: this.id,
      type: this.constructor.name,
      x: this.x,
      y: this.y,
      fill: this.fill,
      stroke: this.stroke,
      lineWidth: this.lineWidth,
      opacity: this.opacity,
      ...this.serializeSpecificData()  // 子类特定数据
    };
  }

  // 由子类实现，序列化特定数据
  protected abstract serializeSpecificData(): any;
}
```

#### 具体子类实现

```typescript
// shapes/Rect.ts - 矩形
export class Rect extends Shape {
  public width: number;
  public height: number;

  constructor(options: RectOptions) {
    super(options);
    this.width = options.width || 0;
    this.height = options.height || 0;
  }

  // 实现抽象方法：绘制
  protected draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.rect(this.x, this.y, this.width, this.height);
  }

  // 实现抽象方法：碰撞检测
  containsPoint(point: Vector): boolean {
    return point.x >= this.x &&
           point.x <= this.x + this.width &&
           point.y >= this.y &&
           point.y <= this.y + this.height;
  }

  // 实现抽象方法：边界框
  getBounds(): AABB {
    return new AABB(this.x, this.y, this.width, this.height);
  }

  // 实现抽象方法：序列化特定数据
  protected serializeSpecificData(): any {
    return {
      width: this.width,
      height: this.height
    };
  }
}
```

```typescript
// shapes/Circle.ts - 圆形
export class Circle extends Shape {
  public radius: number;

  constructor(options: CircleOptions) {
    super(options);
    this.radius = options.radius || 0;
  }

  protected draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
  }

  containsPoint(point: Vector): boolean {
    const dx = point.x - this.x;
    const dy = point.y - this.y;
    return Math.sqrt(dx * dx + dy * dy) <= this.radius;
  }

  getBounds(): AABB {
    return new AABB(
      this.x - this.radius,
      this.y - this.radius,
      this.radius * 2,
      this.radius * 2
    );
  }

  protected serializeSpecificData(): any {
    return {
      radius: this.radius
    };
  }
}
```

---

## 设计模式总结

### 模式组合

在实际项目中，多个设计模式通常组合使用：

```typescript
// Editor.ts - 组合使用多种模式
export class Editor extends EventEmitter {  // 发布-订阅模式
  private canvas: Canvas;
  private scene: Scene;
  private toolManager: ToolManager;        // 策略模式
  private commandManager: CommandManager;  // 命令模式

  constructor(options: EditorOptions) {
    super();  // 继承 EventEmitter

    // 初始化各个模块
    this.canvas = new Canvas(options.canvas);
    this.scene = new Scene();
    this.toolManager = new ToolManager(this);
    this.commandManager = new CommandManager();

    // 监听命令执行事件
    this.commandManager.on('historyChanged', () => {
      this.emit('historyChanged');  // 发布-订阅
    });
  }

  // 使用策略模式切换工具
  setTool(type: ToolType): void {
    this.toolManager.setTool(type);
  }

  // 使用命令模式执行操作
  addShape(shape: Shape): void {
    const command = new AddShapeCommand(this.scene, shape);  // 命令模式
    this.commandManager.execute(command);
    this.emit('shapeAdded', shape);  // 发布-订阅
  }

  // 撤销/重做
  undo(): void {
    if (this.commandManager.undo()) {
      this.emit('undone');  // 发布-订阅
      this.requestRender();
    }
  }

  redo(): void {
    if (this.commandManager.redo()) {
      this.emit('redone');  // 发布-订阅
      this.requestRender();
    }
  }
}
```

### 模式选择原则

| 问题场景 | 推荐模式 | 理由 |
|---------|---------|------|
| 需要动态切换算法/行为 | 策略模式 | 避免 if-else，便于扩展 |
| 需要撤销/重做 | 命令模式 | 将操作封装为对象 |
| 模块间需要解耦通信 | 发布-订阅 | 松耦合，灵活性高 |
| 根据类型创建对象 | 工厂模式 | 集中管理对象创建逻辑 |
| 需要全局唯一实例 | 单例模式 | 确保只有一个实例 |
| 算法骨架固定，细节可变 | 模板方法 | 代码复用，扩展灵活 |

### 设计模式的价值

1. **可维护性**：代码结构清晰，职责分离，易于理解和修改
2. **可扩展性**：新增功能时，遵循开闭原则，无需修改现有代码
3. **可测试性**：每个模块职责单一，便于编写单元测试
4. **可复用性**：通用模块可以在其他项目中复用

---

**最后更新**: 2025-12-04
