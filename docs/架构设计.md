# 架构设计 - web协绘坊

本文档详细介绍 web协绘坊的整体架构设计，包括前后端架构、核心引擎设计、数据流和模块组织。

## 目录

- [整体架构](#整体架构)
- [前端架构](#前端架构)
  - [分层架构](#分层架构)
  - [核心引擎设计](#核心引擎设计)
  - [模块组织](#模块组织)
- [后端架构](#后端架构)
  - [服务器架构](#服务器架构)
  - [数据模型设计](#数据模型设计)
  - [WebSocket 服务](#websocket-服务)
- [数据流设计](#数据流设计)
  - [本地操作流程](#本地操���流程)
  - [协同编辑流程](#协同编辑流程)
- [核心系统详解](#核心系统详解)
  - [坐标转换系统](#坐标转换系统)
  - [事件系统](#事件系统)
  - [渲染系统](#渲染系统)
  - [性能优化系统](#性能优化系统)

---

## 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         Web 浏览器                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────��───────────────────────────────┐    │
│  │              Vue 3 UI 层（组件）                    │    │
│  │  ├─ EditorExample.vue （编辑器��组件）              │    │
│  │  ├─ Toolbar.vue （工具栏）                         │    │
│  │  └─ PropertyPanel.vue （属性面板）                 │    │
│  └────────────────────────────────────────────────────┘    │
│                         ↓↑                                  │
│  ┌────────────────────────────────────────────────────┐    │
│  │           核心引擎（框架无关）                       │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  Editor（编辑器主类）                     │     │    │
│  │  │  ├─ Canvas（画布封装）                    │     │    │
│  │  │  ├─ Scene（场景管理）                     │     │    │
│  │  │  ├─ ToolManager（工具管理）               │     │    │
│  │  │  ├─ CommandManager（命令管理）            │     │    │
│  │  │  └─ EventEmitter（事件系统）              │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  │                                                     │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  工具系统（5种绘图工具）                  │     │    │
│  │  │  SelectTool | RectTool | CircleTool      │     │    │
│  │  │  PenTool | BrushTool                     │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  │                                                     │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  图形系统                                 │     │    │
│  │  │  Shape | Rect | Circle | Line            │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  │                                                     │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  数学库与算法                             │     │    │
│  │  │  Vector | Matrix | AABB                  │     │    │
│  │  │  QuadTree | PathSmoothing                │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────┘    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                          ↓↑ WebSocket
┌─────────────────────────────────────────────────────────────┐
│                      Node.js 服务器                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │           Koa HTTP 服务器                           │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  REST API 路由                            │     │    │
│  │  │  GET /health                             │     │    │
│  │  │  GET /api/rooms/:roomId                  │     │    │
│  │  │  POST /api/rooms                         │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────┘    │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │         WebSocket 服务器（ws）                       │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  WebSocketService                        │     │    │
│  │  │  - 连接管理                               │     │    │
│  │  │  - 消息广播                               │     │    │
│  │  │  - 房间管理                               │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────┘    │
│                         ↓↑                                  │
│  ┌────────────────────────────────────────────────────┐    │
│  │           业务服务层                                 │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  RoomService（房间服务）                  │     │    │
│  │  │  - createRoom()                          │     │    │
│  │  │  - getRoom()                             │     │    │
│  │  │  - addShape()                            │     │    │
│  │  │  - removeShape()                         │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────┘    │
│                         ↓↑                                  │
│  ┌─────────────��──────────────────────────────────────┐    │
│  │          MongoDB 数据库（Mongoose ORM）              │    │
│  │  ┌──────────────────────────────────────────┐     │    │
│  │  │  Room（房间模型）                         │     │    │
│  │  │  - roomId, name, shapes, users           │     │    │
│  │  │                                           │     │    │
│  │  │  Operation（操作历史模型）                │     │    │
│  │  │  - roomId, userId, type, data            │     │    │
│  │  └──────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────┘    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 前端架构

### 分层架构

前端采用清晰的分层架构，实现了 UI 层与业务逻辑的解耦：

```
┌─────────────────────────────────────┐
│       表现层（Presentation）         │
│   Vue 组件 + Hooks                  │
│   - EditorExample.vue               │
│   - useEditor.ts                    │
│   - useCollaboration.ts             │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│        应用层（Application）         │
│   Editor 编辑器主类                  │
│   - 协调各个模块                     │
│   - 处理用户交互                     │
│   - 管理应用状态                     │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│         领域层（Domain）             │
│   核心业务逻辑（框架无关）           │
│   - 工具系统（ToolManager）          │
│   - 命令系统（CommandManager）       │
│   - 场景管理（Scene）                │
│   - 图形系统（Shapes）               │
└─────────────────────────────────────┘
              ↓↑
┌─────────────────────────────────────┐
│       基础设施层（Infrastructure）   │
│   技术支撑                           │
│   - Canvas 渲染（Canvas）            │
│   - 数学库（Vector, Matrix）         │
│   - 算法库（QuadTree, PathSmoothing）│
│   - 事件系统（EventEmitter）         │
└─────────────────────────────────────┘
```

**关键设计原则**：
1. **框架无关**：核心引擎使用纯 TypeScript，不依赖 Vue
2. **单向数据流**：数据从上层流向下层，事件从下层传递��上层
3. **职责分离**：每个模块有明确的职责，便于测试和维护

---

### 核心引擎设计

核心引擎采用模块化设计，各模块职责清晰：

```typescript
// Editor.ts - 编辑器主类
export class Editor {
  // 子模块
  private canvas: Canvas;           // 画布管理
  private scene: Scene;             // 场景管理
  private toolManager: ToolManager; // 工具管理
  private commandManager: CommandManager; // 命令管理
  private eventEmitter: EventEmitter;    // 事件系统

  constructor(options: EditorOptions) {
    // 初始化各个模块
    this.canvas = new Canvas(options.canvas);
    this.scene = new Scene();
    this.toolManager = new ToolManager(this);
    this.commandManager = new CommandManager();
    this.eventEmitter = new EventEmitter();

    // 设置事件监听
    this.setupEventListeners();

    // 启动渲染循环
    this.startRenderLoop();
  }

  // 协调各模块工作
  executeCommand(command: Command) {
    this.commandManager.execute(command);
    this.eventEmitter.emit('commandExecuted', command);
  }

  // 对外提供统一的接口
  setTool(toolType: ToolType) {
    this.toolManager.setTool(toolType);
  }
}
```

**模块间的交互**：
- **Canvas** → 提供渲染能力
- **Scene** → 管理所有图形对象
- **ToolManager** → 处理用户交互
- **CommandManager** → 管理操作历史
- **EventEmitter** → 跨模块通信

---

### 模块组织

```
src/
├── core/                     # 核心引擎（框架无关）
│   ├── Canvas.ts             # Canvas 封装与坐标转换
│   ├── Editor.ts             # 编辑器主类
│   ├── Scene.ts              # 场景管理（图形列表）
│   ├── ToolManager.ts        # 工具管理器
│   ├── CommandManager.ts     # 命令管理器（撤销/重做）
│   ├── EventEmitter.ts       # 事件系统
│   ├── ErrorHandler.ts       # 错误处理器
│   └── config.ts             # 全局配置
│
├── tools/                    # 绘图工具
│   ├── Tool.ts               # 工具基类（抽象类）
│   ├── SelectTool.ts         # 选择工具
│   ├── RectTool.ts           # 矩形工具
│   ├── CircleTool.ts         # 圆形工具
│   ├── PenTool.ts            # 钢笔工具
│   └── BrushTool.ts          # 画笔工具
│
├── shapes/                   # 图形类
│   ├── Shape.ts              # 图形基类（抽象类）
│   ├── Rect.ts               # 矩形
│   ├── Circle.ts             # 圆形
│   ├── Line.ts               # 线条
│   └── index.ts              # 工厂函数（createShapeFromJSON）
│
├── math/                     # 数学库
│   ├── Vector.ts             # 向量运算
│   ├── Matrix.ts             # 矩阵变换
│   └── AABB.ts               # 轴对齐包围盒
│
├── algorithms/               # 算法库
│   ├── PathSmoothing.ts      # 路径平滑算法
│   └── QuadTree.ts           # 四叉树空间分区
│
├── commands/                 # 命令实现（命令模式）
│   ├── Command.ts            # 命令接口
│   ├── AddShapeCommand.ts    # 添加图形命令
│   ├── DeleteShapeCommand.ts # 删除图形命令
│   ├── TransformCommand.ts   # 变换命令
│   └── UpdateStyleCommand.ts # 更新样式命令
│
├── components/               # Vue 组件（UI 层）
│   ├── EditorExample.vue     # 编辑器主组件
│   ├── Toolbar.vue           # 工具栏
│   └── PropertyPanel.vue     # 属性面板
│
├── hooks/                    # Vue Hooks
│   ├── useEditor.ts          # 编辑器 Hook
│   └── useCollaboration.ts   # 协同编辑 Hook
│
└── types/                    # TypeScript 类型定义
    ├── editor.ts             # 编辑器相关类型
    ├── shapes.ts             # 图形相关类型
    └── tools.ts              # 工具相关类型
```

---

## 后端架构

### 服务器架构

后端采用轻量级的 Koa 框架 + WebSocket，实现了高性能的实时通信：

```
┌─────────────────────────────────────────────┐
│            HTTP Server (Koa)                │
│  ┌─────────────────────────────────────┐   │
│  │  Router (Koa Router)                │   │
│  │  ├─ GET  /health                    │   │
│  │  ├─ GET  /api/rooms/:roomId         │   │
│  │  ├─ POST /api/rooms                 │   │
│  │  └─ GET  /api/rooms/:roomId/ops     │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────────┐
│         WebSocket Server (ws)               │
│  ┌─────────────────────────────────────┐   │
│  │  WebSocketService                   │   │
│  │  ├─ handleConnection()              │   │
│  │  ├─ handleMessage()                 │   │
│  │  ├─ broadcastToRoom()               │   │
│  │  └─ handleDisconnection()           │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────────┐
│           Business Layer                    │
│  ┌─────────────────────────────────────┐   │
│  │  RoomService                        │   │
│  │  ├─ createRoom(roomId, name)        │   │
│  │  ├─ getRoom(roomId)                 │   │
│  │  ├─ addUser(roomId, user)           │   │
│  │  ├─ removeUser(roomId, userId)      │   │
│  │  ├─ addShape(roomId, shape)         │   │
│  │  ├─ removeShape(roomId, shapeId)    │   │
│  │  └─ updateShape(roomId, shapeId)    │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                    ↓↑
┌─────────────────────────────────────────────┐
│         Data Access Layer                   │
│  ┌─────────────────────────────────────┐   │
│  │  MongoDB + Mongoose                 │   │
│  │  ├─ Room Model                      │   │
│  │  └─ Operation Model                 │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
```

**服务器入口**（`server/src/index.js`）：
```javascript
import Koa from 'koa';
import { WebSocketServer } from 'ws';
import { connectDB } from './config/database.js';
import WebSocketService from './services/WebSocketService.js';

const app = new Koa();
const server = createServer(app.callback());
const wss = new WebSocketServer({ server });

// WebSocket 连接处理
wss.on('connection', (ws, req) => {
  WebSocketService.handleConnection(ws, req);
});

// 启动服务器
await connectDB();
server.listen(3000, () => {
  console.log('Server started on port 3000');
});
```

---

### 数据模型设计

#### Room 模型（房间）

```javascript
// server/src/models/Room.js
const shapeSchema = new mongoose.Schema({
  id: { type: String, required: true },
  type: { type: String, required: true },
  data: { type: mongoose.Schema.Types.Mixed, required: true }
}, { _id: false });

const roomSchema = new mongoose.Schema({
  roomId: {
    type: String,
    required: true,
    unique: true,
    index: true  // 索引优化查询
  },
  name: {
    type: String,
    default: 'Untitled Room'
  },
  shapes: [shapeSchema],  // 房间中的所有图形
  users: [{
    userId: String,
    name: String,
    color: String,
    joinedAt: Date
  }],
  version: {
    type: Number,
    default: 0  // 用于乐观锁
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
}, {
  timestamps: true  // 自动管理 createdAt 和 updatedAt
});
```

#### Operation 模型（操作历史）

```javascript
// server/src/models/Operation.js
const operationSchema = new mongoose.Schema({
  roomId: {
    type: String,
    required: true,
    index: true  // 索引优化房间查询
  },
  userId: {
    type: String,
    required: true
  },
  type: {
    type: String,
    required: true,
    enum: ['add-shape', 'delete-shape', 'transform-shape', 'update-style']
  },
  data: {
    type: mongoose.Schema.Types.Mixed  // 灵活存储各种操作数据
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true  // 索引优化时间查询
  }
});

// 组合索引：按房间和时间查询操作历史
operationSchema.index({ roomId: 1, timestamp: -1 });
```

---

### WebSocket 服务

#### 消息协议设计

**客户端 → 服务器**：
```typescript
// 加入房间
interface JoinMessage {
  type: 'join';
  roomId: string;
  userId: string;
  data: {
    name: string;
    color: string;
  };
}

// 操作命令
interface CommandMessage {
  type: 'command';
  roomId: string;
  userId: string;
  timestamp: number;
  data: {
    operation: {
      command: {
        type: 'add-shape' | 'delete-shape' | 'transform-shape' | 'update-style';
        shape?: any;
        shapeId?: string;
        transform?: any;
        style?: any;
      };
    };
  };
}

// 离开房间
interface LeaveMessage {
  type: 'leave';
  roomId: string;
  userId: string;
}
```

**服务器 → 客户端**：
```typescript
// 初始化同步（新用户加入时）
interface InitSyncMessage {
  type: 'init_sync';
  data: {
    shapes: ShapeData[];  // 房间中的所有图形
    users: UserInfo[];    // 在线用户列表
  };
}

// 用户加入通知
interface UserJoinedMessage {
  type: 'user_joined';
  data: {
    userId: string;
    name: string;
    color: string;
  };
}

// 用户离开通知
interface UserLeftMessage {
  type: 'user_left';
  data: {
    userId: string;
  };
}

// 操作广播（转发给其他用户）
interface CommandBroadcast {
  type: 'command';
  userId: string;  // 发起操作的用户
  timestamp: number;
  data: {
    operation: {
      command: CommandData;
    };
  };
}
```

#### WebSocket 服务实现

```javascript
// server/src/services/WebSocketService.js
class WebSocketService {
  // 房间 → 连接映射
  static rooms = new Map(); // roomId → Set<WebSocket>

  static handleConnection(ws, req) {
    console.log('[WS] New connection');

    ws.on('message', async (data) => {
      const message = JSON.parse(data);

      switch (message.type) {
        case 'join':
          await this.handleJoin(ws, message);
          break;
        case 'command':
          await this.handleCommand(ws, message);
          break;
        case 'leave':
          await this.handleLeave(ws, message);
          break;
      }
    });

    ws.on('close', () => {
      this.handleDisconnection(ws);
    });
  }

  static async handleJoin(ws, message) {
    const { roomId, userId, data } = message;

    // 添加到房间
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }
    this.rooms.get(roomId).add(ws);
    ws.roomId = roomId;
    ws.userId = userId;

    // 获取房间数据
    const room = await RoomService.getRoom(roomId);

    // 发送初始化同步
    ws.send(JSON.stringify({
      type: 'init_sync',
      data: {
        shapes: room.shapes,
        users: room.users
      }
    }));

    // 广播用户加入
    this.broadcastToRoom(roomId, {
      type: 'user_joined',
      data: { userId, ...data }
    }, ws);

    // 添加用户到数据库
    await RoomService.addUser(roomId, { userId, ...data });
  }

  static async handleCommand(ws, message) {
    const { roomId, userId, data } = message;
    const { operation } = data;

    // 保存操作到数据库
    await RoomService.processCommand(roomId, operation.command);

    // 广播给房间内其他用户
    this.broadcastToRoom(roomId, {
      type: 'command',
      userId,
      timestamp: message.timestamp,
      data
    }, ws);
  }

  static broadcastToRoom(roomId, message, excludeWs = null) {
    const clients = this.rooms.get(roomId);
    if (!clients) return;

    const msgStr = JSON.stringify(message);
    clients.forEach(client => {
      if (client !== excludeWs && client.readyState === WebSocket.OPEN) {
        client.send(msgStr);
      }
    });
  }
}
```

---

## 数据流设计

### 本地操作流程

```
用户交互（鼠标/键盘）
        ↓
  Tool（工具处理）
        ↓
  创建 Command 对象
        ↓
CommandManager.execute()
        ↓
   Command.execute()
   （修改 Scene）
        ↓
  EventEmitter.emit('commandExecuted')
        ↓
   ┌──────────┴──────────┐
   ↓                     ↓
Renderer.render()   WebSocket.send()
（本地渲染）        （远程同步）
```

**代码示例**：
```typescript
// 1. 用户点击绘制矩形
onPointerDown(event: PointerEvent) {
  const startPoint = this.editor.screenToWorld(
    new Vector(event.clientX, event.clientY)
  );

  // 2. 创建矩形图形
  this.currentRect = new Rect({
    x: startPoint.x,
    y: startPoint.y,
    width: 0,
    height: 0
  });
}

onPointerUp() {
  if (this.currentRect) {
    // 3. 创建添加命令
    const command = new AddShapeCommand(
      this.editor.scene,
      this.currentRect
    );

    // 4. 执行命令
    this.editor.executeCommand(command);
    // → CommandManager 添加到历史栈
    // → Command.execute() 将图形添加到 Scene
    // → EventEmitter 触发 'commandExecuted' 事件
    // → Renderer 重新渲染
    // → WebSocket 发送给其他用户
  }
}
```

---

### 协同编辑流程

```
用户 A 操作                        用户 B 接收
    ↓                                  ↑
执行本地命令                           │
    ↓                                  │
CommandManager.execute()              │
    ↓                                  │
序列化命令                             │
    ↓                                  │
WebSocket.send()  ──────────────────→ WebSocket.onmessage
                                       ↓
                                  解析消息
                                       ↓
                                  反序列化命令
                                       ↓
                                  设置标志位
                                  isReceivingRemote = true
                                       ↓
                                  直接修改 Scene
                                  （跳过 CommandManager）
                                       ↓
                                  Renderer.render()
                                       ↓
                                  isReceivingRemote = false
```

**关键代码**：
```typescript
// 发送方（用户 A）
const originalExecute = commandManager.execute.bind(commandManager);
commandManager.execute = (command: Command) => {
  // 1. 本地执行
  originalExecute(command);

  // 2. 发送给其他用户
  if (!isReceivingRemote && ws?.readyState === WebSocket.OPEN) {
    const commandData = serializeCommand(command);
    ws.send(JSON.stringify({
      type: 'command',
      roomId,
      userId,
      data: { operation: { command: commandData } }
    }));
  }
};

// 接收方（用户 B）
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);

  if (message.type === 'command') {
    const { command } = message.data.operation;

    // 设置标志位，防止循环广播
    isReceivingRemote = true;

    // 直接修改 Scene，不通过 CommandManager
    // （避免添加到历史栈，因为这是远程操作）
    if (command.type === 'add-shape') {
      const shape = createShapeFromJSON(command.shape);
      editor.scene.add(shape);
      editor.renderer.requestRender();
    }

    isReceivingRemote = false;
  }
};
```

---

## 核心系统详解

### 坐标转换系统

Canvas 坐标系与世界坐标系之间的转换是图形编辑器的核心问题。

#### 坐标系统

```
屏幕坐标（Screen）     世界坐标（World）
┌──────────────┐      ┌──────────────┐
│ (0,0)        │      │              │
│              │      │   (0,0)      │
│              │      │      *       │
│              │      │              │
│              │      │              │
└──────────────┘      └──────────────┘

视图变换 = 平移 × 缩放
```

#### 实现

```typescript
// Canvas.ts
export class Canvas {
  private viewMatrix = new Matrix();  // 视图矩阵
  private zoom = 1.0;                 // 缩放级别
  private pan = new Vector(0, 0);     // 平移偏移

  // 屏幕坐标 → 世界坐标
  screenToWorld(screenPoint: Vector): Vector {
    const viewMatrixInverse = this.viewMatrix.invert();
    return viewMatrixInverse.transformPoint(screenPoint);
  }

  // 世界坐标 → 屏幕坐标
  worldToScreen(worldPoint: Vector): Vector {
    return this.viewMatrix.transformPoint(worldPoint);
  }

  // 缩放（以鼠标为中心）
  zoomAt(point: Vector, delta: number) {
    // 1. 计算新的缩放级别
    const newZoom = Math.max(0.1, Math.min(10, this.zoom * (1 + delta)));
    const zoomFactor = newZoom / this.zoom;

    // 2. 计算缩放中心点在世界坐标中的位置
    const worldPoint = this.screenToWorld(point);

    // 3. 更新缩放
    this.zoom = newZoom;

    // 4. 调整平移，使缩放中心点保持不变
    const newScreenPoint = this.worldToScreen(worldPoint);
    const offset = point.subtract(newScreenPoint);
    this.pan = this.pan.add(offset);

    // 5. 更新视图矩阵
    this.updateViewMatrix();
  }

  // 更新视图矩阵
  private updateViewMatrix() {
    // 视图矩阵 = 平移矩阵 × 缩放矩阵
    this.viewMatrix = Matrix.identity()
      .translate(this.pan.x, this.pan.y)
      .scale(this.zoom, this.zoom);
  }
}
```

---

### 事件系统

事件系统采用发布-订阅模式，实现模块间的解耦通信。

```typescript
// EventEmitter.ts
export class EventEmitter {
  private listeners = new Map<string, Set<Function>>();

  // 注册事件监听器
  on(event: string, callback: Function) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);
  }

  // 注销事件监听器
  off(event: string, callback: Function) {
    this.listeners.get(event)?.delete(callback);
  }

  // 触发事件
  emit(event: string, ...args: any[]) {
    this.listeners.get(event)?.forEach(cb => cb(...args));
  }

  // 一次性监听器
  once(event: string, callback: Function) {
    const wrapper = (...args: any[]) => {
      callback(...args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }
}
```

**使用示例**：
```typescript
// 订阅事件
editor.on('shapeAdded', (shape: Shape) => {
  console.log('Shape added:', shape);
  updatePropertyPanel(shape);
});

editor.on('selectionChanged', (shapes: Shape[]) => {
  updateToolbar(shapes);
});

editor.on('commandExecuted', (command: Command) => {
  syncToServer(command);
});

// 触发事件
editor.emit('shapeAdded', newShape);
```

---

### 渲染系统

渲染系统采用 requestAnimationFrame 实现 60 FPS 流畅渲染。

```typescript
// Renderer.ts（在 Editor 中）
export class Editor {
  private animationId: number | null = null;

  // 启动渲染循环
  private startRenderLoop() {
    const renderFrame = () => {
      this.render();
      this.animationId = requestAnimationFrame(renderFrame);
    };
    renderFrame();
  }

  // 渲染方法
  render() {
    const ctx = this.canvas.ctx;

    // 1. 清空画布
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // 2. 应用视图变换
    ctx.save();
    this.canvas.applyViewTransform(ctx);

    // 3. 渲染网格
    this.renderGrid();

    // 4. 渲染所有图形
    this.scene.shapes.forEach(shape => {
      shape.render(ctx);
    });

    // 5. 渲染选择框
    if (this.selection.selectedShapes.length > 0) {
      this.renderSelection();
    }

    // 6. 渲染变换控制点
    if (this.selection.isTransforming) {
      this.renderTransformHandles();
    }

    ctx.restore();
  }

  // 清理
  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}
```

---

### 性能优化系统

#### 四叉树空间分区

用于快速查询特定区域内的图形，避免遍历所有图形。

```typescript
// QuadTree.ts
export class QuadTree {
  private maxObjects = 10;  // 每个节点最多10个对象
  private maxLevels = 5;    // 最大深度5层
  private level: number;
  private bounds: AABB;
  private objects: QuadTreeItem[] = [];
  private nodes: QuadTree[] = [];

  // 插入对象
  insert(item: QuadTreeItem) {
    // 如果已经分裂，尝试插入到子节点
    if (this.nodes.length > 0) {
      const index = this.getIndex(item.getBounds());
      if (index !== -1) {
        this.nodes[index].insert(item);
        return;
      }
    }

    // 否则插入到当前节点
    this.objects.push(item);

    // 如果超过容量且未达到最大深度，则分裂
    if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
      if (this.nodes.length === 0) {
        this.split();
      }

      // 重新分配对象到子节点
      let i = 0;
      while (i < this.objects.length) {
        const index = this.getIndex(this.objects[i].getBounds());
        if (index !== -1) {
          this.nodes[index].insert(this.objects.splice(i, 1)[0]);
        } else {
          i++;
        }
      }
    }
  }

  // 查询区域内的对象
  retrieve(bounds: AABB): QuadTreeItem[] {
    const index = this.getIndex(bounds);
    const returnObjects = this.objects.slice();

    if (this.nodes.length > 0) {
      if (index !== -1) {
        returnObjects.push(...this.nodes[index].retrieve(bounds));
      } else {
        // 跨越多个象限，查询所有子节点
        for (const node of this.nodes) {
          returnObjects.push(...node.retrieve(bounds));
        }
      }
    }

    return returnObjects;
  }

  // 分裂成4个子节点
  private split() {
    const subWidth = this.bounds.width / 2;
    const subHeight = this.bounds.height / 2;
    const x = this.bounds.x;
    const y = this.bounds.y;

    this.nodes[0] = new QuadTree(this.level + 1, new AABB(x + subWidth, y, subWidth, subHeight));
    this.nodes[1] = new QuadTree(this.level + 1, new AABB(x, y, subWidth, subHeight));
    this.nodes[2] = new QuadTree(this.level + 1, new AABB(x, y + subHeight, subWidth, subHeight));
    this.nodes[3] = new QuadTree(this.level + 1, new AABB(x + subWidth, y + subHeight, subWidth, subHeight));
  }

  // 确定对象属于哪个象限
  private getIndex(bounds: AABB): number {
    const verticalMidpoint = this.bounds.x + this.bounds.width / 2;
    const horizontalMidpoint = this.bounds.y + this.bounds.height / 2;

    const inTopQuadrant = bounds.y < horizontalMidpoint && bounds.y + bounds.height < horizontalMidpoint;
    const inBottomQuadrant = bounds.y > horizontalMidpoint;

    if (bounds.x < verticalMidpoint && bounds.x + bounds.width < verticalMidpoint) {
      if (inTopQuadrant) return 1;
      if (inBottomQuadrant) return 2;
    } else if (bounds.x > verticalMidpoint) {
      if (inTopQuadrant) return 0;
      if (inBottomQuadrant) return 3;
    }

    return -1; // 跨越多个象限
  }
}
```

**使用场景**：
```typescript
// 点击选择图形时，只查询点击区域附近的图形
const clickBounds = new AABB(clickPoint.x - 5, clickPoint.y - 5, 10, 10);
const candidates = quadTree.retrieve(clickBounds);

// 只对候选图形进行精确的点击测试
for (const shape of candidates) {
  if (shape.containsPoint(clickPoint)) {
    return shape;
  }
}
```

---

## 总结

本架构设计的核心优势：

1. **前后端分离**：清晰的职责划分，独立开发和部署
2. **框架无关**：核心引擎使用纯 TypeScript，可移植到任何框架
3. **模块化设计**：每个模块职责单一，便于测试和维护
4. **性能优化**：四叉树、AABB、路径简化等多种优化手段
5. **实时协同**：WebSocket + MongoDB 实现可靠的实时同步
6. **可扩展性**：策略模式、命令模式等设计模式支持功能扩展

这种架构设计使得项目既有良好的性能表现，又具备优秀的可维护性和可扩展性。

---

**最后更新**: 2025-12-04
